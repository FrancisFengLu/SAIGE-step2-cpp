================================================================================
SAIGE STEP 2 C++ STANDALONE CONVERSION - SESSION NOTES
================================================================================
Date: Feb 10-11, 2025

================================================================================
SESSION: Feb 10, 2025 - INITIAL SCAFFOLDING
================================================================================

### Step 1 Output Now Available

Step 1 (in /Jan_30_comparison/) was completed this session with:
- Real variance ratio computation (was stubbed, now matches R)
- 11 .arma binary output files for Step 2 to load
- varianceRatio.txt in R-compatible format
- See /Jan_30_comparison/SESSION_NOTES.txt and CLAUDE.md for full details

Step 1 output format is documented in this folder's CLAUDE.md (Section:
"Step 1 -> Step 2 Interface") and in the HTML reference at
/Jan_30_comparison/reference/SCORENULLPACK_AND_ARMA_OUTPUT.html

### Step 2 Files Ported (5 files, all cross-checked)

Ported from /SAIGE/src/ (Rcpp) to standalone C++:

  cct.cpp/hpp        - Cauchy combination test
                       Trivial port: only header change (#include <armadillo>)

  spa_binary.cpp/hpp - Binary trait Saddlepoint Approximation
                       12 Rcpp::List returns replaced with C++ structs:
                         RootResult { root, niter, Isconverge }
                         SaddleResult { pval, isSaddle }
                         SPAResult { pvalue, Isconverge }
                       All R::pnorm calls replaced with boost::math::cdf

  spa.cpp/hpp        - SPA dispatcher
                       Updated to use struct returns from spa_binary
                       Survival trait: throws "not yet implemented"

  saige_test.cpp/hpp - SAIGEClass with score test, SPA, Firth correction
                       1257 -> 1118 lines
                       Rcpp::Environment set.seed -> std::mt19937
                       ER binary section is a stub

  UTIL.cpp/hpp       - Math utilities
                       nb() uses std::bernoulli_distribution
                       getWeights() uses boost::math::pdf(beta_distribution)

  getMem.cpp/hpp     - Memory reporting
                       Added macOS support via mach/mach.h

### Stubs Created

  null_model_loader.cpp/hpp - Interface for loading Step 1 .arma output
                              loadArmaVec/loadArmaMat implemented
                              loadNullModel() throws "not yet implemented"

  genotype_reader.cpp/hpp   - Placeholder for PLINK/VCF/BGEN reading

### Infrastructure Created

  CLAUDE.md          - Full project doc (conversion rules, logic flow, file map)
  Makefile           - Based on Step 1's, target: saige-step2

### Cross-Check Results

All 5 ported files verified by comparison subagent against originals:
  - CCT: PASS
  - SPA_binary: PASS (all 12 struct conversions correct)
  - SPA: PASS
  - saige_test: PASS
  - UTIL: PASS

### Files Not Yet Ported

  main.cpp           - CLI entry point (YAML config, mainMarkerInCPP, mainRegionInCPP)
  group_file.cpp     - Gene/region group file parser
  er_binary.cpp      - Efficient resampling for rare variants
  Survival SPA       - Not yet implemented

================================================================================
SESSION: Feb 11, 2025 - TODO LIST & FUNCTION MAPPING
================================================================================

### Created TODO.txt

Created comprehensive TODO.txt with:
- Full function-to-file mapping from STEP2_CALL_GRAPH_v2.html (15 sections)
  to standalone C++ target files
- Every function from the HTML call graph mapped to its standalone target
  with status (DONE / STUB / NEW)
- 7-phase implementation checklist with dependencies
- Dependency graph showing blocking relationships
- Critical path for single-variant and region testing

### File Status Summary (as of Feb 11)

Already ported (DONE):
  saige_test.cpp/hpp  — SAIGEClass, all score tests, SPA dispatch, Firth,
                         conditional analysis, variance ratio assignment
  spa_binary.cpp/hpp  — All SPA functions (12 struct conversions)
  spa.cpp/hpp         — SPA dispatcher
  cct.cpp/hpp         — Cauchy combination test
  UTIL.cpp/hpp        — Weights, imputation, utilities
  getMem.cpp/hpp      — Memory reporting

Stub (interface done, body throws):
  null_model_loader.cpp/hpp — loadArmaVec/loadArmaMat done,
                               loadNullModel/loadVarianceRatios throw

Not yet created:
  main.cpp            — CLI, mainMarkerInCPP, mainRegionInCPP
  genotype_reader.cpp — PLINK/BGEN/VCF/PGEN readers
  group_file.cpp      — Group file parser + annoIndicatorMat
  skat.cpp            — SKAT/Burden/SKAT-O + Davies method
  er_binary.cpp       — Efficient resampling (binary only, low priority)
  ldmat.cpp           — LD matrix (optional)

### Corrected Note

Previous session listed genotype_reader.cpp/hpp as a stub, but the files
don't actually exist in the directory. Only null_model_loader has a stub.

================================================================================
NEXT STEPS
================================================================================

Critical path (see TODO.txt for full details):

Phase 1: null_model_loader  — Implement body (JSON + .arma + VR loading)
Phase 2: genotype_reader    — PLINK reader first (reuse Step 1 patterns)
Phase 3: main.cpp           — CLI + mainMarkerInCPP (single-variant loop)
Phase 4: group_file.cpp     — Parse group file
Phase 5: skat.cpp           — BURDEN/SKAT/SKAT-O + Davies method
Phase 6: main.cpp           — mainRegionInCPP (region testing)
Phase 7: er_binary, ldmat   — Lower priority

================================================================================
SESSION: Feb 17, 2025 - PHASES 1-6 COMPLETE
================================================================================

### All 6 Phases Implemented

Phase 1: null_model_loader.cpp — DONE
  - Loads JSON manifest + 11 .arma binary files from Step 1
  - Loads varianceRatio.txt (MAC categories + VR values)
  - Populates SAIGEClass members via setSAIGEobjInCPP()
  - Review agent: PASS

Phase 2: genotype_reader.cpp/hpp — DONE (547 lines)
  - PLINK .bed/.bim/.fam reading (from Step 1 patterns)
  - GenotypeReader class: open(), readMarker(), getN(), getM()
  - Marker metadata (CHR, POS, REF, ALT, AF, MAC)
  - Mean imputation for missing genotypes
  - Review agent: PASS

Phase 3: main.cpp — DONE (initial 1234 lines)
  - CLI entry point with YAML config parsing
  - setAssocTest_GlobalVarsInCPP() — global test parameters
  - setSAIGEobjInCPP() — null model initialization
  - Unified_getMarkerPval() — score test + SPA dispatch
  - mainMarkerInCPP() — single-variant marker loop
  - Output file writing (CHR, POS, REF, ALT, AC, AF, p-value, etc.)
  - Review agent: PASS (all 27 parameters correct, no algorithmic differences)

Phase 4: group_file.cpp/hpp — DONE (530 + 64 lines)
  - checkGroupFile(): Two-pass format validation (2 or 3 lines per gene)
  - readRegionChunk(): Parses gene regions, builds annoIndicatorMat
  - RegionData struct: variantIDs, annotations, weights, annoVec, genoIndex

Phase 5: skat.cpp/hpp — DONE (760 + 80 lines)
  - Davies method (qfc algorithm, AS 155) for chi-squared mixtures
  - Liu moment-matching method (fallback when Davies fails)
  - SKAT-O optimal.adj with rho grid search + integration correction
  - get_SKAT_pvalue() entry point dispatching SKAT/BURDEN/SKAT-O
  - SKATResult struct: pvalue_SKATO, pvalue_Burden, pvalue_SKAT, beta_Burden, se_Burden

Phase 6: main.cpp — DONE (expanded to 3071 lines)
  - setRegion_GlobalVarsInCPP() — region-specific globals
  - openOutfile/openOutfile_SKATO/openOutfile_singleinGroup — output headers
  - writeOutfile_BURDEN/writeOutfile_singleInGroup — output writing
  - convert_str_to_log() — string p-value to log(p) conversion
  - SPA_ER_kernel_related_Phiadj_fast_new() — SPA Phi adjustment
  - get_newPhi_scaleFactor_traitType() — binary trait Phi scaling
  - get_CCT_pvalue() — CCT wrapper for non-NA p-values
  - mainRegionInCPP() — full region testing pipeline (~1100 lines):
    * Marker reading loop with QC, MAC filtering, URV classification
    * P1Mat/P2Mat computation with chunking for large regions
    * VarMat assembly from chunks
    * Annotation × MAF stratification (nested loops)
    * Weight application (Beta(MAF,1,25) default)
    * URV collapsing (MAC ≤ threshold → pseudo-markers)
    * Score vector and Phi matrix construction per stratum
    * SPA Phi adjustment for binary traits
    * SKAT/BURDEN/SKAT-O dispatch via get_SKAT_pvalue()
    * CCT combination across annotation×MAF groups
    * Single-variant-in-group output
  - main() updated for region testing via YAML config
  - Review agent: pending

### Build Status

All 11 source files compile and link successfully:
  UTIL.cpp, cct.cpp, genotype_reader.cpp, getMem.cpp, group_file.cpp,
  main.cpp, null_model_loader.cpp, saige_test.cpp, skat.cpp, spa.cpp,
  spa_binary.cpp
Binary: saige-step2 (919KB)
Only warnings: deprecated sprintf, SuperLU headers, duplicate libraries

### Remaining Work

Phase 7 (lower priority):
  er_binary.cpp  — Efficient resampling for rare variants
  ldmat.cpp      — LD matrix output (optional)

Not yet implemented:
  Survival trait SPA — throws "not yet implemented"
  VCF/BGEN/PGEN genotype readers — only PLINK supported

Integration testing:
  No test data has been run through either single-variant or region path yet
  R checkpoint comparison still needed

================================================================================
SESSION: Feb 18, 2026 - VALIDATION COMPLETE (EXACT MATCH)
================================================================================

### Single-Variant Testing: C++ Matches R Exactly

Ran end-to-end comparison of C++ standalone vs R SAIGE Step 2 on the
quantitative example dataset (128,868 markers, N=1000).

Result: **ALL 644,340 values EXACT match** (0 differences across BETA, SE,
Tstat, var, p.value — relative difference = 0 for every comparison).

C++ completed in 1.0 seconds vs R's 4.0 seconds (4x speedup).

### Comparison Pipeline Created

Built a 4-step comparison pipeline in test/:

  Step 1: convert_rda_to_arma.R  — Extract .rda null model → .arma + JSON
  Step 2: run_r_step2.R          — Run R SAIGE Step 2 via pixi
  Step 3: ./saige-step2           — Run C++ Step 2 with converted model
  Step 4: compare_step2.R        — Compare results column-by-column

Orchestrator: test/run_comparison.sh

### Key Fix: genotype_reader.cpp — Empty sampleIDs Fallback

Bug: When nullmodel.json had no sampleIDs, setPosSampleInPlink() set
m_N=0, causing "0 markers tested". Fix: Added fallback to use all fam
samples in order (identity mapping) when sampleIDs is empty.

### Key Fix: LOCO Model Mismatch

Initial comparison showed BETA/Tstat sign flips (relDiff≈2.0) but
SE/var exact. Root cause: converter extracted chr 1 LOCO model values,
but R script used LOCO=FALSE (base model). Fix: Changed R script to
LOCO=TRUE so both use the same chr 1 LOCO null model.

### Key Fix: Armadillo Binary Format

R's write_arma_vec() initially used ARMA_COL_BIN_FN008 header, but
Armadillo C++ vec::load(arma_binary) expects ARMA_MAT_BIN_FN008.
Fix: Changed R converter to use ARMA_MAT_BIN_FN008 for all files.

### Pixi Environment Setup

SAIGE R package runs via pixi (not system R):
  Manifest: /Jan_30_comparison/code_copy/SAIGE_isolated/pixi.toml
  R version: 4.4.3 (osx-64)
  Command pattern:
    ~/.pixi/bin/pixi run --manifest-path=<path>/pixi.toml Rscript <script.R>

System R (4.5.1) does NOT have SAIGE installed. All SAIGE R operations
must use pixi.

### New Files Created

  test/R/convert_rda_to_arma.R    — .rda → .arma converter (420 lines)
  test/R/run_r_step2.R            — R reference Step 2 runner (363 lines)
  test/R/run_r_step2.sh           — Shell wrapper for pixi invocation
  test/compare_step2.R            — Column-by-column comparison script
  test/run_comparison.sh          — End-to-end orchestrator
  code_copy/cpp_standalone/config_compare.yaml — C++ config for comparison
  test/data/nullmodel_from_rda/   — Converted null model (12 files)
  test/R/r_step2_results.txt      — R output (128,858 markers)
  test/output/cpp_compare_results.txt — C++ output (128,868 markers)
  test/RESULTS_step2.txt          — Comparison verdict: PASS

### Call Graph Compliance (from CPP_STANDALONE_CALL_GRAPH.html)

  68 functions: DONE
   3 functions: STUB→DONE (upgraded)
  28 functions: NEW→DONE (new standalone code)
   0 functions: MISSING (er_binary + ldmat both implemented Feb 20)

### Reference HTML Documents

  reference/CPP_STANDALONE_CALL_GRAPH.html — Function mapping
  reference/STEP2_CALL_GRAPH_v2.html       — Computation flow
  reference/STEP2_MATH_EXPLAINED.html      — Math visualization (in progress)

================================================================================
SESSION: Feb 20, 2026 - BINARY + REGION VALIDATION
================================================================================

### Test 2: Binary + Single-Variant — SPA + Firth VALIDATED

Result: MAC > 4 = 100% EXACT (45/45), MAC ≤ 4 = 92% EXACT (23/25)
  - SPA p-values: 100% EXACT for all 70 markers
  - Firth correction: EXACT after fixing offset.arma loading
  - 2 DIFFER markers (rs44 MAC=1, rs56 MAC=2): ER not implemented,
    C++ uses SPA fallback. This is a missing feature, not precision error.

Bug fix: Binary null model converter was not saving the offset vector
(linear predictor from null model). Added offset.arma to converter output.
Without offset, Firth logistic regression produced wrong results.

New files:
  test/R/convert_rda_to_arma_binary.R
  test/R/run_r_step2_binary.R
  code_copy/cpp_standalone/config_compare_binary.yaml
  test/data/nullmodel_from_rda_binary/ (includes offset.arma)
  test/R/r_step2_binary_results.txt
  test/output/cpp_compare_binary_results.txt
  test/RESULTS_step2_binary.txt

### Test 3: Quantitative + Region — BURDEN/SKAT/SKAT-O VALIDATED

Result (2 regions tested):
  BETA_Burden:   max rel error 6.886e-07 (PASS)
  Pvalue_Burden: max rel error 4.880e-04 (PASS)
  Pvalue_SKAT:   max rel error 2.826e-03 (PASS — Davies method)
  Pvalue_SKAT-O: max rel error 5.218e-02 (APPROXIMATE)
  SE_Burden:     max rel error 1.136e-03 (CLOSE)
  MAC/counts:    EXACT

SKAT-O ~5% error is due to Liu moment-matching quantile approximation.
Exact Davies quantile was tested but caused 13x runtime increase for
only 0.5% improvement — not worth the tradeoff.

Cleaned up unused davies_quantile() from skat.cpp (1060 → 983 lines).

New files:
  test/R/run_r_step2_region.R
  code_copy/cpp_standalone/config_compare_region.yaml
  test/output/cpp_compare_region_results.txt

### Validation Summary (all tests)

  Test 1: Quant + Single-Variant  → ALL EXACT (128,868 markers)
  Test 2: Binary + Single-Variant → ALL EXACT (70 markers, ER implemented)
  Test 3: Quant + Region          → BURDEN/SKAT PASS, SKAT-O ~5%
  Test 4: Binary + Region         → NOT YET TESTED

### ER (Efficient Resampling) Implemented

Ported er_binary.cpp/hpp (~530 lines) from 5 SAIGE source files.
Wired into saige_test.cpp getMarkerPval(). Test 2 now 100% EXACT
(previously 2 of 70 markers failed due to ER gap).

Bug fix: resout should be empty vector (not copy of res) when
SKAT res.out is NULL. SKATExactBin_Work handles initialization.

### LDmat (LD Matrix) Implemented

Ported ldmat.cpp/hpp (546 + 73 lines) from SAIGE LDmat.cpp.
Wired into main.cpp with isLDMatrix config option.
Tested with 2 genes (99 markers), outputs:
  - marker_info.txt (per-marker QC info)
  - LDmat.txt (lower-triangular sparse G'G in COO format)
  - index.txt (region start/end row indices)

### Implementation Status: ALL FEATURES COMPLETE

  MISSING functions: 0 (was 2: er_binary, ldmat — both done)
  Remaining unimplemented: survival trait SPA (niche), VCF/BGEN/PGEN readers

================================================================================
SESSION: Feb 20, 2026 (cont.) - TEST 4 BINARY + REGION VALIDATED
================================================================================

### Test 4: Binary + Region — CONDITIONAL PASS

Result (9 rows, 2 regions):
  | Column        | Max Rel Error | Status      |
  |---------------|---------------|-------------|
  | Pvalue_SKAT   | 1.987e-06     | EXACT       |
  | BETA_Burden   | 3.003e-06     | EXACT       |
  | Pvalue_Burden | 3.199e-04     | PASS        |
  | SE_Burden     | 4.880e-04     | PASS        |
  | Pvalue_SKAT-O | 8.485e-02     | APPROXIMATE |
  | MAC/counts    | 0             | EXACT       |

Binary-specific code paths validated:
  - SPA Phi adjustment (get_newPhi_scaleFactor_traitType)
  - SPA_ER_kernel_related_Phiadj_fast_new
  - ER resampling in region context
  - MAC_case / MAC_control counting

SKAT-O ~8.5% error: same Liu approximation issue as Test 3, slightly
amplified by binary SPA Phi adjustment. BURDEN and SKAT themselves
are highly accurate.

New files:
  test/R/run_r_step2_binary_region.R
  test/compare_step2_binary_region.R
  code_copy/cpp_standalone/config_compare_binary_region.yaml
  test/R/r_step2_binary_region_results.txt
  test/output/cpp_compare_binary_region_results.txt
  test/RESULTS_step2_binary_region.txt

### Test 5: Sparse GRM + Single-Variant (scoreTestFast) — ALL EXACT

Result: 644,340/644,340 values EXACT across all 5 columns (128,868 markers).
Model: example_quantitative_sparseGRM.rda (LOCO=FALSE, isFastTest=TRUE)

Code paths exercised:
  - scoreTestFast (fast algebraic formula, all markers first pass)
  - scoreTest with PCG (sparse GRM, MAC ≤ 20 + p < 0.05 re-evaluation)
  - Sparse GRM loading (locationMat + valueVec from converter)
  - VR label format parsing ("value type nMarkers")

Key fixes:
  - VR parser: support 3-column label format ("1 sparse 1")
  - MAC category defaults: auto-apply R's c(10.5, 20.5) for single-VR label
  - null_model_loader.cpp: "theta" key fallback for C++ Step 1 compatibility

Note: 49 markers with MAC ≤ 20 produce negative variance from PCG (sparse
sigma non-symmetric from R's dsTMatrix lower triangle). R outputs p=1;
C++ replicates this exactly. Known SAIGE behavior.

New files:
  test/R/convert_rda_to_arma_sparse.R
  test/R/run_r_step2_sparse.R
  test/compare_step2_sparse.R
  code_copy/cpp_standalone/config_compare_sparse.yaml
  test/data/nullmodel_from_rda_sparse/ (18 files)
  test/RESULTS_step2_sparse.txt

### Validation Summary (5 TESTS COMPLETE)

  Test 1: Quant + Single-Variant  → ALL EXACT (128,868 markers)
  Test 2: Binary + Single-Variant → ALL EXACT (70 markers)
  Test 3: Quant + Region          → BURDEN/SKAT PASS, SKAT-O ~5%
  Test 4: Binary + Region         → BURDEN/SKAT PASS, SKAT-O ~8.5%
  Test 5: Sparse + Single-Variant → ALL EXACT (128,868 markers)

================================================================================
END OF SESSION NOTES
================================================================================
